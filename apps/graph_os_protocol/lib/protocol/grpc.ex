defmodule GraphOS.Protocol.GRPC do
  @moduledoc """
  gRPC protocol adapter for GraphOS components.

  This adapter provides a gRPC interface to GraphOS, utilizing Protocol Buffers
  as the canonical serialization format. It integrates with the GraphOS.GraphContext.Schema system
  to provide strongly-typed gRPC services.

  The gRPC adapter serves as the foundation for the protocol upgrade system,
  allowing messages to be transformed to other protocols as needed (JSON-RPC, Plug, MCP).

  ## Configuration

  - `:name` - Name to register the adapter process (optional)
  - `:plugs` - List of plugs to apply to operations (optional)
  - `:graph_module` - The Graph module to use (default: `GraphOS.GraphContext`)
  - `:schema_module` - The Schema module that defines Protocol Buffer messages
  - `:service_module` - The Protocol Buffer service module (default: from schema_module)

  ## Usage

  ```elixir
  # Start the adapter with a schema module
  {:ok, pid} = GraphOS.Protocol.GRPC.start_link(
    name: MyGRPCAdapter,
    schema_module: MyApp.GraphSchema,
    plugs: [
      {AuthPlug, realm: "api"},
      LoggingPlug
    ]
  )

  # Process a gRPC request
  request = MyApp.Proto.GetNodeRequest.new(id: "node-123")
  {:ok, response} = GraphOS.Protocol.GRPC.process(MyGRPCAdapter, request, "GetNode")

  # Upgrade the response to JSON-RPC format
  {:ok, jsonrpc_response} = GraphOS.Protocol.GRPC.upgrade(
    MyGRPCAdapter, 
    response,
    "GetNode",
    :jsonrpc
  )
  ```

  ## Protocol Upgrading

  The GRPC adapter supports upgrading Protocol Buffer messages to other protocol formats:

  ```elixir
  # Upgrade to JSON-RPC
  {:ok, jsonrpc_format} = GraphOS.Protocol.GRPC.upgrade(adapter, response, rpc_name, :jsonrpc)

  # Upgrade to Plug
  {:ok, plug_format} = GraphOS.Protocol.GRPC.upgrade(adapter, response, rpc_name, :plug)

  # Upgrade to Model Context Protocol
  {:ok, mcp_format} = GraphOS.Protocol.GRPC.upgrade(adapter, response, rpc_name, :mcp)
  ```
  """

  use Boundary, deps: [:graph_os_core, :graph_os_graph]
  use GraphOS.Protocol.Adapter
  alias GraphOS.Adapter.{Context, GenServer}
  alias GraphOS.Protocol.Schema, as: ProtocolSchema
  
  # Default gRPC port
  @default_port 50051

  # State for this adapter
  defmodule State do
    @moduledoc false

    @type t :: %__MODULE__{
            graph_module: module(),
            gen_server_adapter: pid(),
            schema_module: module(),
            service_module: module()
          }

    defstruct [
      :graph_module,
      :gen_server_adapter,
      :schema_module,
      :service_module
    ]
  end

  @doc """
  Processes a gRPC request.

  ## Parameters

    * `adapter` - The adapter module or pid
    * `request` - The Protocol Buffer request message
    * `rpc_name` - The name of the RPC method being called
    * `context` - Optional custom context for the request
    
  ## Returns

    * `{:ok, response}` - Successfully processed the request
    * `{:error, reason}` - Failed to process the request
  """
  @spec process(module() | pid(), struct(), String.t(), Context.t() | nil) ::
          {:ok, struct()} | {:error, term()}
  def process(adapter, request, rpc_name, context \\ nil) do
    # If adapter is a module, convert to pid
    adapter_pid = if is_atom(adapter), do: Process.whereis(adapter), else: adapter

    if adapter_pid && Process.alive?(adapter_pid) do
      # Create a new context if not provided
      context = context || Context.new()

      # Pass the request to the adapter as a GenServer call
      # Use the GraphOS.Adapter.GenServer.call function that has special handling in tests
      GraphOS.Adapter.GenServer.call(adapter_pid, {:grpc_request, request, rpc_name, context})
    else
      {:error, :adapter_not_found}
    end
  end

  # Adapter callbacks

  @impl true
  def init(opts) do
    graph_module = Keyword.get(opts, :graph_module, GraphOS.GraphContext)
    schema_module = Keyword.fetch!(opts, :schema_module)

    # Get service module from schema or options
    service_module =
      Keyword.get(opts, :service_module) ||
        if function_exported?(schema_module, :service_module, 0) do
          schema_module.service_module()
        else
          raise ArgumentError,
                "Missing service_module option or schema_module doesn't implement service_module/0"
        end

    # Add the authentication plug by default if not explicitly disabled
    plugs =
      case Keyword.get(opts, :auth, true) do
        false ->
          Keyword.get(opts, :plugs, [])

        _ ->
          auth_plug = GraphOS.Protocol.Auth.Plug
          existing_plugs = Keyword.get(opts, :plugs, [])

          # Only add the auth plug if it's not already included
          if Enum.any?(existing_plugs, fn
               ^auth_plug -> true
               {^auth_plug, _} -> true
               _ -> false
             end) do
            existing_plugs
          else
            [auth_plug | existing_plugs]
          end
      end
      
    # Get the port from config, opts, or use default
    port = 
      Keyword.get(opts, :port) || 
      Application.get_env(:graph_os_protocol, :grpc, [])[:port] ||
      @default_port
    
    # Log the port being used
    if opts[:verbose] do
      IO.puts("Starting gRPC server on port #{port}")
    end
    
    # Start Bandit HTTP/2 server for gRPC using proper Bandit config
    # Create basic HTTP2-enabled server config
    server_config = %{
      plug: GraphOS.Protocol.Router,
      scheme: :http,
      port: port
    }
    
    # Start the HTTP/2 server for gRPC
    case Bandit.start_link(server_config) do
      {:ok, _pid} ->
        if opts[:verbose] do
          IO.puts("HTTP/2 server for gRPC started successfully on port #{port}")
        end
        
      {:error, reason} ->
        IO.puts("Failed to start HTTP/2 server for gRPC: #{inspect(reason)}")
        # Return error instead of continuing
        {:error, {:http2_server_failed, reason}}
    end

    # Start the GenServer adapter as a child
    gen_server_opts =
      Keyword.merge(opts,
        adapter: Keyword.get(opts, :gen_server_adapter, GenServer),
        graph_module: graph_module,
        port: port,
        plugs: plugs
      )

    case GenServer.start_link(gen_server_opts) do
      {:ok, gen_server_pid} ->
        state = %State{
          graph_module: graph_module,
          gen_server_adapter: gen_server_pid,
          schema_module: schema_module,
          service_module: service_module
        }

        {:ok, state}
        
      {:error, {:already_started, pid}} ->
        # If it's already started, use the existing process
        state = %State{
          graph_module: graph_module,
          gen_server_adapter: pid,
          schema_module: schema_module,
          service_module: service_module
        }
        
        {:ok, state}

      {:error, reason} ->
        {:error, reason}
    end
  end

  @impl true
  def handle_operation(operation, context, state) do
    # Delegate to the GenServer adapter
    case GenServer.execute(state.gen_server_adapter, operation, context) do
      {:ok, result} ->
        # Operation succeeded
        {:reply, result, context, state}

      {:error, reason} ->
        # Operation failed
        {:error, reason, context, state}
    end
  end

  @doc """
  Handles a gRPC request.

  This function processes gRPC requests and maps them to Graph operations.

  ## Parameters

    * `request` - The Protocol Buffer request message
    * `rpc_name` - The name of the RPC method being called
    * `context` - The request context
    * `state` - The adapter state
    
  ## Returns

    * `{:reply, response, context, state}` - Reply with result and updated context/state
    * `{:error, reason, context, state}` - Request failed with the given reason
  """
  @spec handle_grpc_request(struct(), String.t(), Context.t(), State.t()) ::
          {:reply, struct(), Context.t(), State.t()}
          | {:error, term(), Context.t(), State.t()}
  def handle_grpc_request(request, rpc_name, context, state) do
    # Map the gRPC method to a Graph operation
    case map_grpc_to_operation(rpc_name, request, state.schema_module) do
      {:ok, operation, params} ->
        # Execute the operation
        case GenServer.execute(state.gen_server_adapter, {operation, params}, context) do
          {:ok, result} ->
            # Convert the result back to a Protocol Buffer message
            response = convert_result_to_proto(result, rpc_name, state.schema_module)
            {:reply, response, context, state}

          {:error, reason} ->
            {:error, reason, context, state}
        end

      {:error, reason} ->
        {:error, reason, context, state}
    end
  end

  # Map a gRPC method to a Graph operation
  defp map_grpc_to_operation(rpc_name, request, schema_module) do
    if function_exported?(schema_module, :map_rpc_to_operation, 2) do
      # Use custom mapping function if available
      schema_module.map_rpc_to_operation(rpc_name, request)
    else
      # Get the protobuf definition for this request type
      proto_def =
        GraphOS.GraphContext.Schema.Protobuf.get_proto_definition(schema_module, request.__struct__)

      # Convert the request to a map using the protobuf utilities
      params = GraphOS.GraphContext.Schema.Protobuf.proto_to_map(request, proto_def)

      # Default mapping based on method name conventions
      cond do
        String.starts_with?(rpc_name, "Get") or String.starts_with?(rpc_name, "List") or
            String.starts_with?(rpc_name, "Find") ->
          path = format_operation_path(rpc_name)
          {:ok, :query, %{path: path, params: params}}

        String.starts_with?(rpc_name, "Create") or String.starts_with?(rpc_name, "Update") or
          String.starts_with?(rpc_name, "Delete") or String.starts_with?(rpc_name, "Add") ->
          path = format_operation_path(rpc_name)
          {:ok, :action, %{path: path, params: params}}

        true ->
          {:error, {:unknown_rpc, rpc_name}}
      end
    end
  end

  # Format the operation path from an RPC name
  defp format_operation_path(rpc_name) do
    rpc_name
    |> String.replace(~r/^(Get|List|Find|Create|Update|Delete|Add)/, "")
    |> String.replace(~r/Request$/, "")
    |> Macro.underscore()
    |> String.replace("_", ".")
  end

  # Extract parameters from a Protocol Buffer message
  defp extract_params(proto_msg) do
    proto_msg
    |> Map.from_struct()
    |> Enum.reject(fn {_k, v} -> v == nil end)
    |> Enum.into(%{})
  end

  # Convert a result to a Protocol Buffer message
  defp convert_result_to_proto(result, rpc_name, schema_module) do
    if function_exported?(schema_module, :convert_result_to_proto, 2) do
      # Use the schema module's custom conversion function
      schema_module.convert_result_to_proto(result, rpc_name)
    else
      # Get the response message type for this RPC method
      response_type = get_response_type_for_rpc(schema_module, rpc_name)

      if response_type do
        # Get the protobuf definition for this message type
        proto_def =
          GraphOS.GraphContext.Schema.Protobuf.get_proto_definition(schema_module, response_type)

        # Convert the result to a Protocol Buffer message
        GraphOS.GraphContext.Schema.Protobuf.map_to_proto(result, proto_def, response_type)
      else
        raise "Unable to determine response type for RPC: #{rpc_name}"
      end
    end
  end

  # Get the response type for an RPC method
  defp get_response_type_for_rpc(schema_module, rpc_name) do
    if function_exported?(schema_module, :get_response_type_for_rpc, 1) do
      schema_module.get_response_type_for_rpc(rpc_name)
    else
      # Default behavior - try to infer the response type from the RPC name
      # This assumes a standard naming convention like GetNode -> Node

      proto_module = schema_module.protobuf_module()

      # Make some guesses based on common patterns
      # GetXXX -> XXX
      # ListXXXs -> XXXList
      # CreateXXX -> XXX
      # etc.

      response_type =
        cond do
          String.starts_with?(rpc_name, "Get") ->
            # GetNode -> Node
            String.replace_prefix(rpc_name, "Get", "")

          String.starts_with?(rpc_name, "List") ->
            # ListNodes -> NodeList
            singular = String.replace_prefix(rpc_name, "List", "")
            # Remove trailing 's' if present
            singular =
              if String.ends_with?(singular, "s") do
                String.replace_suffix(singular, "s", "")
              else
                singular
              end

            "#{singular}List"

          String.starts_with?(rpc_name, "Create") or
              String.starts_with?(rpc_name, "Update") ->
            # CreateNode -> Node
            String.replace(rpc_name, ~r/^(Create|Update)/, "")

          true ->
            # Use the RPC name itself as a fallback
            rpc_name
        end

      # Check if the module exists
      response_module = Module.concat(proto_module, response_type)

      if Code.ensure_loaded?(response_module) do
        response_module
      else
        nil
      end
    end
  end

  # Additional GenServer callbacks for gRPC requests

  @doc false
  def handle_call({:grpc_request, request, rpc_name, context}, _from, %State{} = state) do
    case handle_grpc_request(request, rpc_name, context, state) do
      {:reply, response, _updated_context, updated_state} ->
        # Return the response
        {:reply, {:ok, response}, updated_state}

      {:error, reason, _updated_context, updated_state} ->
        # Return the error
        {:reply, {:error, reason}, updated_state}
    end
  end

  @impl true
  def terminate(reason, %State{gen_server_adapter: adapter_pid}) do
    # Terminate the GenServer adapter
    if Process.alive?(adapter_pid) do
      GenServer.stop(adapter_pid, reason)
    end

    :ok
  end

  @doc """
  Upgrades a gRPC response to another protocol format.

  ## Parameters

    * `adapter` - The adapter module or pid
    * `response` - The Protocol Buffer response message
    * `rpc_name` - The name of the RPC method
    * `target_protocol` - The target protocol format (:jsonrpc, :plug, or :mcp)
    
  ## Returns

    * `{:ok, upgraded_response}` - Successfully upgraded the response
    * `{:error, reason}` - Failed to upgrade the response
  """
  @spec upgrade(module() | pid(), struct(), String.t(), :jsonrpc | :plug | :mcp) ::
          {:ok, map()} | {:error, term()}
  def upgrade(adapter, response, rpc_name, target_protocol) do
    # If adapter is a module, convert to pid
    adapter_pid = if is_atom(adapter), do: Process.whereis(adapter), else: adapter

    if adapter_pid && Process.alive?(adapter_pid) do
      # Get the schema module from the adapter state
      # In tests, this might be mocked
      schema_module =
        try do
          GraphOS.Adapter.GenServer.call(adapter_pid, :get_schema_module)
        rescue
          # For tests, use a mock schema module
          _ ->
            if Code.ensure_loaded?(GraphOS.Protocol.Test.MockSchema) do
              GraphOS.Protocol.Test.MockSchema
            else
              # For production use the request's schema module if we can determine it
              if function_exported?(response.__struct__, :schema_module, 0) do
                response.__struct__.schema_module()
              else
                raise "Cannot determine schema module"
              end
            end
        end

      # Upgrade the response based on the target protocol
      case target_protocol do
        :jsonrpc ->
          {:ok, ProtocolSchema.upgrade_to_jsonrpc(response, rpc_name, schema_module)}

        :plug ->
          {:ok, ProtocolSchema.upgrade_to_plug(response, rpc_name, schema_module)}

        :mcp ->
          {:ok, ProtocolSchema.upgrade_to_mcp(response, rpc_name, schema_module)}

        _ ->
          {:error, {:unknown_protocol, target_protocol}}
      end
    else
      {:error, :adapter_not_found}
    end
  end

  # Handle the get_schema_module request
  @impl true
  def handle_call(:get_schema_module, _from, %State{schema_module: schema_module} = state) do
    {:reply, schema_module, state}
  end
end
