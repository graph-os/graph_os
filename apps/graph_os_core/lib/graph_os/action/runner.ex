defmodule GraphOS.Action.Runner do
  @moduledoc """
  A GenServer responsible for executing a single GraphOS Action instance.

  It manages the lifecycle of an action execution, including:
  - Receiving the action details (module, function, args, caller).
  - Calling the target action function.
  - Handling synchronous and potentially asynchronous results (e.g., from Tasks).
  - Storing the execution state (pending, running, completed, failed) and result/error.
  - Providing an interface to query the status and result.
  """
  use GenServer

  require Logger

  alias GraphOS.Action.Registry

  # State: %{
  #   execution_id: String.t(),
  #   caller_actor_id: String.t(), # Still useful for logging/context
  #   target_module: module(),    # Module where do_operation lives
  #   operation_atom: atom(),     # e.g., :read, :write
  #   args: map(),                # Arguments for the do_operation function
  #   status: :pending | :running | :completed | :failed,
  #   result: any() | nil,
  #   error: any() | nil,
  #   started_at: DateTime.t() | nil,
  #   finished_at: DateTime.t() | nil
  # }

  # --- Client API ---

  def start_link(opts) do
    # execution_id should be generated by the caller (e.g., Supervisor or Action module)
    # and passed in opts.
    # execution_id = Keyword.fetch!(opts, :execution_id) # No longer needed for name
    # Start as a simple child process without a registered name
    GenServer.start_link(__MODULE__, opts, [])
  end

  @doc """
  Retrieves the current status and result/error of the action execution asynchronously.
  Requires the PID of the runner process.
  """
  def get_status(pid) when is_pid(pid) do
    GenServer.call(pid, :get_status)
  end

  @doc """
  Retrieves the current status synchronously, waiting up to `timeout` milliseconds.
  Requires the PID of the runner process.

  Returns `{:ok, status_map}` if the action completes or fails within the timeout.
  Returns `{:error, :timeout}` if the timeout is reached before completion/failure.
  Returns `{:error, :process_down}` if the process is not alive.
  """
  # Add execution_id argument for logging purposes
  def get_status_sync(pid, execution_id, timeout \\ 5000) when is_pid(pid) do
     # Check if process is alive first
     if Process.alive?(pid) do
       # Use a monitor and receive to implement the wait with timeout
        ref = Process.monitor(pid)
        # Send request
        GenServer.cast(pid, {:get_status_sync, self(), ref})

        receive do
          {:runner_status_sync, ^ref, status_map} ->
            Process.demonitor(ref, [:flush])
            {:ok, status_map}

          {:DOWN, ^ref, :process, _pid, reason} ->
            # Process died before replying or during wait
            Logger.warning("[Action Runner Sync Wait #{execution_id}] Runner process died: #{inspect(reason)}")
            {:error, :process_down} # Or potentially try a final get_status call? Risky.
        after
          timeout ->
            Process.demonitor(ref, [:flush])
            {:error, :timeout}
        end
    end
  end


  @doc """
  Triggers the execution of the action.
  Requires the PID of the runner process.
  """
  def execute(pid) when is_pid(pid) do
    GenServer.cast(pid, :execute)
  end

  # --- Server Callbacks ---

  @impl true
  def init(opts) do
    execution_id = Keyword.fetch!(opts, :execution_id)
    caller_actor_id = Keyword.fetch!(opts, :caller_actor_id) # Keep for context
    target_module = Keyword.fetch!(opts, :target_module)
    operation_atom = Keyword.fetch!(opts, :operation_atom)
    args = Keyword.fetch!(opts, :args)

    state = %{
      execution_id: execution_id,
      caller_actor_id: caller_actor_id,
      target_module: target_module,
      operation_atom: operation_atom,
      args: args,
      status: :pending,
      result: nil,
      error: nil,
      started_at: nil,
      finished_at: nil,
      sync_waiters: %{} # Initialize map for sync waiters
    }

    {:ok, state}
  end

  @impl true
  def handle_cast(:execute, state) do
    Logger.info("[Action Runner #{state.execution_id}] Executing #{state.target_module}.do_#{state.operation_atom}")

    new_state = %{state | status: :running, started_at: DateTime.utc_now()}
    do_operation_fun = :"do_#{state.operation_atom}"

    try do
      # Call the specific implementation function, e.g., TargetModule.do_read(args)
      result = apply(state.target_module, do_operation_fun, [state.args])
      # Assume sync completion for now. Async (Task) needs handle_info implementation.
      handle_execution_result(result, new_state)
    catch
      kind, reason ->
        # Handle cases where do_operation_fun doesn't exist or raises an error
        if kind == :error and reason == :undef do
           Logger.error("[Action Runner #{state.execution_id}] Execution failed: Function #{state.target_module}.#{do_operation_fun}/1 is undefined.")
           final_state = %{new_state | status: :failed, error: {:undef, {state.target_module, do_operation_fun, 1}}, finished_at: DateTime.utc_now()}
           {:noreply, final_state}
        else
          stacktrace = System.stacktrace()
          Logger.error("[Action Runner #{state.execution_id}] Execution failed: #{kind} - #{inspect(reason)}\n#{Exception.format_stacktrace(stacktrace)}")
          final_state = %{new_state | status: :failed, error: {kind, reason, stacktrace}, finished_at: DateTime.utc_now()}
          {:noreply, final_state}
        end
    end
  end

  # Handle synchronous status request used by get_status_sync/2
  def handle_cast({:get_status_sync, caller_pid, ref}, state) do
     # If the process is already finished, reply immediately
     if state.status in [:completed, :failed] do
       send(caller_pid, {:runner_status_sync, ref, build_status_map(state)})
     else
       # Store the requester to reply later when finished
       # Correct syntax for put_in with nested map access
       new_state = put_in(state, [:sync_waiters, ref], caller_pid)
       {:noreply, new_state}
     end
  end
  # Misplaced block removed


  @impl true
  def handle_call(:get_status, _from, state) do
    {:reply, {:ok, build_status_map(state)}, state}
  end

  # TODO: Implement handle_info for true async Task results if do_operation starts Tasks
  # def handle_info({:DOWN, ref, :process, _pid, reason}, state)
  # def handle_info({ref, result}, state) when is_reference(ref)

  # --- Private Helpers ---

  # Removed via_tuple function

  # Handles the immediate result from apply/3 (sync completion)
  defp handle_execution_result(result, state) do
    finished_at = DateTime.utc_now()
    status = determine_final_status(result) # :completed or :failed
    final_result = if status == :completed, do: result, else: nil
    final_error = if status == :failed, do: result, else: nil # Assuming error result is passed directly

    Logger.debug("[Action Runner #{state.execution_id}] Execution completed. Status: #{status}, Result/Error: #{inspect(result)}")

    final_state = %{state |
      status: status,
      result: final_result,
      error: final_error,
      finished_at: finished_at
    }

    # Notify any synchronous waiters
    notify_sync_waiters(final_state)
    final_state_cleaned = Map.delete(final_state, :sync_waiters) # Don't keep waiters in state

    {:noreply, final_state_cleaned}
  end

  # Determines if the raw result indicates success or failure
  defp determine_final_status(result) do
    # Basic check: Assume {:error, _} tuples indicate failure. Adjust as needed.
    case result do
      {:error, _reason} -> :failed
      _ -> :completed
    end
  end

  # Builds the standard status map for replies
  defp build_status_map(state) do
     %{
       status: state.status,
       result: state.result,
       error: state.error,
       started_at: state.started_at,
       finished_at: state.finished_at
     }
  end

  # Sends results to processes waiting via get_status_sync
  defp notify_sync_waiters(state) do
    status_map = build_status_map(state)
    for {ref, pid} <- state.sync_waiters || %{} do
      send(pid, {:runner_status_sync, ref, status_map})
    end
  end
end
